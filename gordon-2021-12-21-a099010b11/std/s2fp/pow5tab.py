#!/usr/bin/env python3

"""
Prints out a Gordon module containing a table of 128-bit significands. They
are powers of five for Daniel Lemire's ``Eisel-Lemire algorithm`` which is
used in decimal to floating point conversions.

More specifically, generates 10^e values for some range of exponents e. The
base two exponents can be inferred using a logarithmic slope of the decimal
exponent. The approximations are normalized and rounded perfectly, ie. within
0.5 ULP of the true value.

Adapted from Rust's ``dec2flt_table.py`` which is adapted from Daniel Lemire's
fast_float ``table_generation.py``. They are available at:
<https://github.com/rust-lang/rust/blob/master/src/etc/dec2flt_table.py> and
<https://github.com/fastfloat/fast_float/blob/main/script/table_generation.py>.
"""
from __future__ import print_function
from math import ceil, floor, log, log2
from fractions import Fraction
from collections import deque

HEADER = """
/*
 * Pre-computed table of powers-of-5 for extended-precision
 * representations.
 *
 * These tables enable fast scaling of the significant digits
 * of a float to the decimal exponent, with minimal rounding
 * errors, in a 128 or 192-bit representation.
 *
 * DO NOT MODIFY! Generated by `pow5tab.py`.
 */
"""

def main():
    min_exp = minimum_exponent(10)
    max_exp = maximum_exponent(10)
    bias = -minimum_exponent(5)

    print(HEADER.strip())
    print()
    print('define int SMALLEST_POWER_OF_FIVE = {};'.format(min_exp))
    print('define int LARGEST_POWER_OF_FIVE = {};'.format(max_exp))
    print('define usz N_POWERS_OF_FIVE = ', end='')
    print('LARGEST_POWER_OF_FIVE - SMALLEST_POWER_OF_FIVE + 1;')
    print()
    print_proper_powers(min_exp, max_exp, bias)


def minimum_exponent(base):
    return ceil(log(5e-324, base) - log(0xFFFFFFFFFFFFFFFF, base))


def maximum_exponent(base):
    return floor(log(1.7976931348623157e+308, base))


def print_proper_powers(min_exp, max_exp, bias):
    powers = deque()

    # Add negative exponents.
    # 2^(2b)/(5^−q) with b=64 + int(math.ceil(log2(5^−q)))
    powers = []
    for q in range(min_exp, 0):
        power5 = 5 ** -q
        z = 0
        while (1 << z) < power5:
            z += 1
        if q >= -27:
            b = z + 127
            c = 2 ** b // power5 + 1
            powers.append((c, q))
        else:
            b = 2 * z + 2 * 64
            c = 2 ** b // power5 + 1
            # truncate
            while c >= (1<<128):
                c //= 2
            powers.append((c, q))

    # Add positive exponents
    for q in range(0, max_exp + 1):
        power5 = 5 ** q
        # move the most significant bit in position
        while power5 < (1<<127):
            power5 *= 2
        # *truncate*
        while power5 >= (1<<128):
            power5 //= 2
        powers.append((power5, q))

    # Print the powers.
    print('struct u128_t {')
    print('    u64 hi;')
    print('    u64 lo;')
    print('}')
    print('')
    print('const U64x2[N_POWERS_OF_FIVE] POWER_OF_FIVE_128 = [')
    lo_mask = (1 << 64) - 1
    for c, exp in powers:
        hi = '0x{:x}'.format(c // (1 << 64))
        lo = '0x{:x}'.format(c % (1 << 64))
        value = '    {{{}, {}}}, '.format(hi, lo)
        comment = '// {}^{}'.format(5, exp)
        print(value.ljust(46, ' ') + comment)
    print('];')


if __name__ == '__main__':
    main()
